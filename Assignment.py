# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xqSE5QErtX1_u5Ekhbv1R7O7E1o6mDcf
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import optimize
import json
from google.colab import files
from pathlib import Path
import time

# Upload CSV
print("ðŸ“ Please upload your CSV file")
uploaded = files.upload()
if len(uploaded) == 0:
    raise SystemExit("No file uploaded.")
csv_name = list(uploaded.keys())[0]
print(f"âœ… Uploaded: {csv_name}")

# Robust loader that handles missing t
def load_xy_optional_t(csv_path):
    try:
        df = pd.read_csv(csv_path, header=0)
    except Exception:
        df = pd.read_csv(csv_path, header=None)
    cols = [str(c).strip().lower() for c in df.columns]

    if 't' in cols and 'x' in cols and 'y' in cols:
        t = pd.to_numeric(df.iloc[:, cols.index('t')], errors='coerce').to_numpy()
        x = pd.to_numeric(df.iloc[:, cols.index('x')], errors='coerce').to_numpy()
        y = pd.to_numeric(df.iloc[:, cols.index('y')], errors='coerce').to_numpy()
        return t, x, y, df

    if 'x' in cols and 'y' in cols and 't' not in cols:
        x = pd.to_numeric(df.iloc[:, cols.index('x')], errors='coerce').to_numpy()
        y = pd.to_numeric(df.iloc[:, cols.index('y')], errors='coerce').to_numpy()
        N = len(x)
        t = np.linspace(6.0, 60.0, N)
        return t, x, y, df

    df2 = pd.read_csv(csv_path, header=None)
    if df2.shape[1] >= 3:
        t = pd.to_numeric(df2.iloc[:,0], errors='coerce').to_numpy()
        x = pd.to_numeric(df2.iloc[:,1], errors='coerce').to_numpy()
        y = pd.to_numeric(df2.iloc[:,2], errors='coerce').to_numpy()
        return t, x, y, df2
    elif df2.shape[1] == 2:
        x = pd.to_numeric(df2.iloc[:,0], errors='coerce').to_numpy()
        y = pd.to_numeric(df2.iloc[:,1], errors='coerce').to_numpy()
        N = len(x)
        t = np.linspace(6.0, 60.0, N)
        return t, x, y, df2
    else:
        raise ValueError("CSV must contain either (t,x,y) or (x,y) or at least two numeric columns.")

# Load & filter data
t_all, x_all, y_all, df_loaded = load_xy_optional_t(csv_name)
print("Rows loaded:", len(t_all))
mask = (t_all > 6.0) & (t_all < 60.0)
t = t_all[mask]
x = x_all[mask]
y = y_all[mask]
N = len(t)
if N == 0:
    raise RuntimeError("No points in 6 < t < 60 after filtering.")
print(f"Using {N} points in (6,60).")

# Model & loss
def model_xy(t_vals, theta_deg, M, X):
    theta = np.deg2rad(theta_deg)
    exp_term = np.exp(M * np.abs(t_vals))
    sin03t = np.sin(0.3 * t_vals)
    x_pred = t_vals * np.cos(theta) - exp_term * sin03t * np.sin(theta) + X
    y_pred = 42 + t_vals * np.sin(theta) + exp_term * sin03t * np.cos(theta)
    return x_pred, y_pred

def mean_l1_for_params(params, t_vals, x_obs, y_obs):
    xp, yp = model_xy(t_vals, params[0], params[1], params[2])
    return float(np.mean(np.abs(x_obs - xp) + np.abs(y_obs - yp)))

# Optimizer: global DE then local refine
bounds = [(0.0, 50.0), (-0.05, 0.05), (0.0, 100.0)]

def run_fit(t_vals, x_obs, y_obs, seed=0, de_pop=30, de_it=1500):
    print("ðŸ” Running Differential Evolution (global search)...")
    start = time.time()
    res_de = optimize.differential_evolution(lambda p: mean_l1_for_params(p, t_vals, x_obs, y_obs),
                                            bounds, strategy='best1bin', maxiter=de_it, popsize=de_pop,
                                            tol=1e-8, polish=False, seed=seed)
    print(f"  DE finished in {time.time() - start:.1f}s â€” best L1 = {res_de.fun:.8g}")
    print("ðŸ”§ Running local refinement (L-BFGS-B)...")
    res_local = optimize.minimize(lambda p: mean_l1_for_params(p, t_vals, x_obs, y_obs),
                                  res_de.x, method='L-BFGS-B', bounds=bounds,
                                  options={'ftol':1e-12, 'maxiter':20000})
    if res_local.success:
        best = res_local.x
        best_loss = res_local.fun
        print(f"  Local refine success â€” L1 = {best_loss:.8g}")
    else:
        best = res_de.x
        best_loss = res_de.fun
        print("  Local refine failed â€” using DE result.")
    return best, best_loss

# Run fitting
best_params, best_loss = run_fit(t, x, y, seed=0, de_pop=30, de_it=1800)
theta_deg, M_val, X_val = best_params
theta_rad = np.deg2rad(theta_deg)

# Save results & plot
outdir = Path("fit_outputs_colab")
outdir.mkdir(exist_ok=True)

x_pred, y_pred = model_xy(t, theta_deg, M_val, X_val)
pd.DataFrame({"t": t, "x_exp": x, "y_exp": y, "x_pred": x_pred, "y_pred": y_pred}).to_csv(outdir/"fitted_points.csv", index=False)

plt.figure(figsize=(7,7))
plt.plot(x, y, '.', markersize=4, label='given points')
plt.plot(x_pred, y_pred, '-', linewidth=1.2, label='fitted curve')
plt.legend()
plt.axis('equal')
plt.title(f"Fitted curve â€” mean L1 = {best_loss:.8g}")
plt.grid(True)
plt.xlabel("x"); plt.ylabel("y")
plt.savefig(outdir/"fit_overlay.png", dpi=150, bbox_inches='tight')
plt.show()

desmos_str = (
    f"(t*cos({theta_rad}) - exp({M_val}*abs(t))*sin(0.3t)*sin({theta_rad}) + {X_val}, "
    f"42 + t*sin({theta_rad}) + exp({M_val}*abs(t))*sin(0.3t)*cos({theta_rad}))"
)
(outdir/"desmos_output.txt").write_text(desmos_str + "\n")
summary = {"theta_deg": float(theta_deg), "theta_rad": float(theta_rad),
           "M": float(M_val), "X": float(X_val), "mean_L1": float(best_loss)}
(outdir/"fit_summary.json").write_text(json.dumps(summary, indent=2))

print("\nâœ… Final fitted parameters:")
print(f"  theta (deg) = {theta_deg:.12g}")
print(f"  M           = {M_val:.12g}")
print(f"  X           = {X_val:.12g}")
print(f"  Mean L1     = {best_loss:.12g}")
print("\nðŸ“ Outputs saved to:", outdir.resolve())
print("\nðŸ§¾ Desmos string:\n", desmos_str)